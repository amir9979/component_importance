valid,type,issue,module,commit,parent,testcase,has_test_annotation,traces,bugged_components,description,extra_description,blamed_components,diff
True,Delta,119,commons-logging,ae4698230a44b0f05d845b8ecad24a1f36a173fc,5c81b031c334f914da9bfb0c09db88cf564de65f,org.apache.commons.logging.impl.WeakHashtableTestCase.testLOGGING_119,False,[],,,,org.apache.commons.logging.impl.weakhashtable.purge(),"u'diff --git a/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java b/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java\nnew file mode 100644\nindex 0000000..64a28f5\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java\n@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the ""License""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an ""AS IS"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package org.apache.commons.logging.impl;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+public class WeakHashtableTestCase extends TestCase {\n+\n+    private static final int WAIT_FOR_THREAD_COMPLETION = 5000; // 5 seconds\n+    private static final int RUN_LOOPS = 3000;\n+    private static final int OUTER_LOOP = 400;\n+    private static final int THREAD_COUNT = 10;\n+\n+    private static WeakHashtable hashtable;\n+\n+    /** Maximum number of iterations before our test fails */\n+    private static final int MAX_GC_ITERATIONS = 50;\n+\n+    private WeakHashtable weakHashtable;\n+    private Long keyOne;\n+    private Long keyTwo;\n+    private Long keyThree;\n+    private Long valueOne;\n+    private Long valueTwo;\n+    private Long valueThree;\n+\n+    public WeakHashtableTestCase(String testName) {\n+        super(testName);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        weakHashtable = new WeakHashtable();\n+\n+        keyOne = new Long(1);\n+        keyTwo = new Long(2);\n+        keyThree = new Long(3);\n+        valueOne = new Long(100);\n+        valueTwo = new Long(200);\n+        valueThree = new Long(300);\n+\n+        weakHashtable.put(keyOne, valueOne);\n+        weakHashtable.put(keyTwo, valueTwo);\n+        weakHashtable.put(keyThree, valueThree);\n+    }\n+\n+    /** Tests public boolean contains(Object value) */\n+    public void testContains() throws Exception {\n+        assertFalse(weakHashtable.contains(new Long(1)));\n+        assertFalse(weakHashtable.contains(new Long(2)));\n+        assertFalse(weakHashtable.contains(new Long(3)));\n+        assertTrue(weakHashtable.contains(new Long(100)));\n+        assertTrue(weakHashtable.contains(new Long(200)));\n+        assertTrue(weakHashtable.contains(new Long(300)));\n+        assertFalse(weakHashtable.contains(new Long(400)));\n+    }\n+\n+    /** Tests public boolean containsKey(Object key) */\n+    public void testContainsKey() throws Exception {\n+        assertTrue(weakHashtable.containsKey(new Long(1)));\n+        assertTrue(weakHashtable.containsKey(new Long(2)));\n+        assertTrue(weakHashtable.containsKey(new Long(3)));\n+        assertFalse(weakHashtable.containsKey(new Long(100)));\n+        assertFalse(weakHashtable.containsKey(new Long(200)));\n+        assertFalse(weakHashtable.containsKey(new Long(300)));\n+        assertFalse(weakHashtable.containsKey(new Long(400)));\n+    }\n+\n+    /** Tests public boolean containsValue(Object value) */\n+    public void testContainsValue() throws Exception {\n+        assertFalse(weakHashtable.containsValue(new Long(1)));\n+        assertFalse(weakHashtable.containsValue(new Long(2)));\n+        assertFalse(weakHashtable.containsValue(new Long(3)));\n+        assertTrue(weakHashtable.containsValue(new Long(100)));\n+        assertTrue(weakHashtable.containsValue(new Long(200)));\n+        assertTrue(weakHashtable.containsValue(new Long(300)));\n+        assertFalse(weakHashtable.containsValue(new Long(400)));\n+    }\n+\n+    /** Tests public Enumeration elements() */\n+    public void testElements() throws Exception {\n+        ArrayList elements = new ArrayList();\n+        for (Enumeration e = weakHashtable.elements(); e.hasMoreElements();) {\n+            elements.add(e.nextElement());\n+        }\n+        assertEquals(3, elements.size());\n+        assertTrue(elements.contains(valueOne));\n+        assertTrue(elements.contains(valueTwo));\n+        assertTrue(elements.contains(valueThree));\n+    }\n+\n+    /** Tests public Set entrySet() */\n+    public void testEntrySet() throws Exception {\n+        Set entrySet = weakHashtable.entrySet();\n+        for (Iterator it = entrySet.iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            Object key = entry.getKey();\n+            if (keyOne.equals(key)) {\n+                assertEquals(valueOne, entry.getValue());\n+            } else if (keyTwo.equals(key)) {\n+                assertEquals(valueTwo, entry.getValue());\n+            } else if (keyThree.equals(key)) {\n+                assertEquals(valueThree, entry.getValue());\n+            } else {\n+                fail(""Unexpected key"");\n+            }\n+        }\n+    }\n+\n+    /** Tests public Object get(Object key) */\n+    public void testGet() throws Exception {\n+        assertEquals(valueOne, weakHashtable.get(keyOne));\n+        assertEquals(valueTwo, weakHashtable.get(keyTwo));\n+        assertEquals(valueThree, weakHashtable.get(keyThree));\n+        assertNull(weakHashtable.get(new Long(50)));\n+    }\n+\n+    /** Tests public Enumeration keys() */\n+    public void testKeys() throws Exception {\n+        ArrayList keys = new ArrayList();\n+        for (Enumeration e = weakHashtable.keys(); e.hasMoreElements();) {\n+            keys.add(e.nextElement());\n+        }\n+        assertEquals(3, keys.size());\n+        assertTrue(keys.contains(keyOne));\n+        assertTrue(keys.contains(keyTwo));\n+        assertTrue(keys.contains(keyThree));\n+    }\n+\n+    /** Tests public Set keySet() */\n+    public void testKeySet() throws Exception {\n+        Set keySet = weakHashtable.keySet();\n+        assertEquals(3, keySet.size());\n+        assertTrue(keySet.contains(keyOne));\n+        assertTrue(keySet.contains(keyTwo));\n+        assertTrue(keySet.contains(keyThree));\n+    }\n+\n+    /** Tests public Object put(Object key, Object value) */\n+    public void testPut() throws Exception {\n+        Long anotherKey = new Long(2004);\n+        weakHashtable.put(anotherKey, new Long(1066));\n+\n+        assertEquals(new Long(1066), weakHashtable.get(anotherKey));\n+\n+        // Test compliance with the hashtable API re nulls\n+        Exception caught = null;\n+        try {\n+            weakHashtable.put(null, new Object());\n+        }\n+        catch (Exception e) {\n+            caught = e;\n+        }\n+        assertNotNull(""did not throw an exception adding a null key"", caught);\n+        caught = null;\n+        try {\n+            weakHashtable.put(new Object(), null);\n+        }\n+        catch (Exception e) {\n+            caught = e;\n+        }\n+        assertNotNull(""did not throw an exception adding a null value"", caught);\n+    }\n+\n+    /** Tests public void putAll(Map t) */\n+    public void testPutAll() throws Exception {\n+        Map newValues = new HashMap();\n+        Long newKey = new Long(1066);\n+        Long newValue = new Long(1415);\n+        newValues.put(newKey, newValue);\n+        Long anotherNewKey = new Long(1645);\n+        Long anotherNewValue = new Long(1815);\n+        newValues.put(anotherNewKey, anotherNewValue);\n+        weakHashtable.putAll(newValues);\n+\n+        assertEquals(5, weakHashtable.size());\n+        assertEquals(newValue, weakHashtable.get(newKey));\n+        assertEquals(anotherNewValue, weakHashtable.get(anotherNewKey));\n+    }\n+\n+    /** Tests public Object remove(Object key) */\n+    public void testRemove() throws Exception {\n+        weakHashtable.remove(keyOne);\n+        assertEquals(2, weakHashtable.size());\n+        assertNull(weakHashtable.get(keyOne));\n+    }\n+\n+    /** Tests public Collection values() */\n+    public void testValues() throws Exception {\n+        Collection values = weakHashtable.values();\n+        assertEquals(3, values.size());\n+        assertTrue(values.contains(valueOne));\n+        assertTrue(values.contains(valueTwo));\n+        assertTrue(values.contains(valueThree));\n+    }\n+\n+    public void testRelease() throws Exception {\n+        assertNotNull(weakHashtable.get(new Long(1)));\n+        ReferenceQueue testQueue = new ReferenceQueue();\n+        WeakReference weakKeyOne = new WeakReference(keyOne, testQueue);\n+\n+        // lose our references\n+        keyOne = null;\n+        keyTwo = null;\n+        keyThree = null;\n+        valueOne = null;\n+        valueTwo = null;\n+        valueThree = null;\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while(true) {\n+            System.gc();\n+            if(iterations++ > MAX_GC_ITERATIONS){\n+                fail(""Max iterations reached before resource released."");\n+            }\n+\n+            if(weakHashtable.get(new Long(1)) == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+\n+        // some JVMs seem to take a little time to put references on\n+        // the reference queue once the reference has been collected\n+        // need to think about whether this is enough to justify\n+        // stepping through the collection each time...\n+        while(testQueue.poll() == null) {}\n+\n+        // Test that the released objects are not taking space in the table\n+        assertEquals(""underlying table not emptied"", 0, weakHashtable.size());\n+    }\n+\n+    public static class StupidThread extends Thread {\n+\n+        public StupidThread(String name) {\n+            super(name);\n+        }\n+\n+        public void run() {\n+            for (int i = 0; i < RUN_LOOPS; i++) {\n+                hashtable.put(""key"" + "":"" + i%10, Boolean.TRUE);\n+                if(i%50 == 0) {\n+                    yield();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testLOGGING_119() throws Exception {\n+        Thread [] t = new Thread[THREAD_COUNT];\n+        for (int j=1; j <= OUTER_LOOP; j++) {\n+            hashtable = new WeakHashtable();\n+            for (int i = 0; i < t.length; i++) {\n+                t[i] = new StupidThread(""Thread:"" + i);\n+                t[i].setDaemon(true); // Otherwise we cannot exit\n+                t[i].start();\n+            }\n+            for (int i = 0; i < t.length; i++) {\n+                t[i].join(WAIT_FOR_THREAD_COMPLETION);\n+                if (t[i].isAlive()) {\n+                    break; // at least one thread is stuck\n+                }\n+            }\n+            int active=0;\n+            for (int i = 0; i < t.length; i++) {\n+                if (t[i].isAlive()) {\n+                    active++;\n+                }\n+            }\n+            if (active > 0) {\n+                fail(""Attempt: "" + j + "" Stuck threads: "" + active);\n+            }\n+        }\n+    }\n+}'"
True,Delta,119,commons-logging,ae4698230a44b0f05d845b8ecad24a1f36a173fc,5c81b031c334f914da9bfb0c09db88cf564de65f,org.apache.commons.logging.impl.WeakHashtableTestCase.testLOGGING_119,False,[],,,,org.apache.commons.logging.impl.weakhashtable.purge(),"u'diff --git a/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java b/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java\nnew file mode 100644\nindex 0000000..64a28f5\n--- /dev/null\n+++ b/src/test/java/org/apache/commons/logging/impl/WeakHashtableTestCase.java\n@@ -0,0 +1,306 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the ""License""); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an ""AS IS"" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+\n+package org.apache.commons.logging.impl;\n+\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.WeakReference;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import junit.framework.TestCase;\n+\n+public class WeakHashtableTestCase extends TestCase {\n+\n+    private static final int WAIT_FOR_THREAD_COMPLETION = 5000; // 5 seconds\n+    private static final int RUN_LOOPS = 3000;\n+    private static final int OUTER_LOOP = 400;\n+    private static final int THREAD_COUNT = 10;\n+\n+    private static WeakHashtable hashtable;\n+\n+    /** Maximum number of iterations before our test fails */\n+    private static final int MAX_GC_ITERATIONS = 50;\n+\n+    private WeakHashtable weakHashtable;\n+    private Long keyOne;\n+    private Long keyTwo;\n+    private Long keyThree;\n+    private Long valueOne;\n+    private Long valueTwo;\n+    private Long valueThree;\n+\n+    public WeakHashtableTestCase(String testName) {\n+        super(testName);\n+    }\n+\n+    protected void setUp() throws Exception {\n+        super.setUp();\n+        weakHashtable = new WeakHashtable();\n+\n+        keyOne = new Long(1);\n+        keyTwo = new Long(2);\n+        keyThree = new Long(3);\n+        valueOne = new Long(100);\n+        valueTwo = new Long(200);\n+        valueThree = new Long(300);\n+\n+        weakHashtable.put(keyOne, valueOne);\n+        weakHashtable.put(keyTwo, valueTwo);\n+        weakHashtable.put(keyThree, valueThree);\n+    }\n+\n+    /** Tests public boolean contains(Object value) */\n+    public void testContains() throws Exception {\n+        assertFalse(weakHashtable.contains(new Long(1)));\n+        assertFalse(weakHashtable.contains(new Long(2)));\n+        assertFalse(weakHashtable.contains(new Long(3)));\n+        assertTrue(weakHashtable.contains(new Long(100)));\n+        assertTrue(weakHashtable.contains(new Long(200)));\n+        assertTrue(weakHashtable.contains(new Long(300)));\n+        assertFalse(weakHashtable.contains(new Long(400)));\n+    }\n+\n+    /** Tests public boolean containsKey(Object key) */\n+    public void testContainsKey() throws Exception {\n+        assertTrue(weakHashtable.containsKey(new Long(1)));\n+        assertTrue(weakHashtable.containsKey(new Long(2)));\n+        assertTrue(weakHashtable.containsKey(new Long(3)));\n+        assertFalse(weakHashtable.containsKey(new Long(100)));\n+        assertFalse(weakHashtable.containsKey(new Long(200)));\n+        assertFalse(weakHashtable.containsKey(new Long(300)));\n+        assertFalse(weakHashtable.containsKey(new Long(400)));\n+    }\n+\n+    /** Tests public boolean containsValue(Object value) */\n+    public void testContainsValue() throws Exception {\n+        assertFalse(weakHashtable.containsValue(new Long(1)));\n+        assertFalse(weakHashtable.containsValue(new Long(2)));\n+        assertFalse(weakHashtable.containsValue(new Long(3)));\n+        assertTrue(weakHashtable.containsValue(new Long(100)));\n+        assertTrue(weakHashtable.containsValue(new Long(200)));\n+        assertTrue(weakHashtable.containsValue(new Long(300)));\n+        assertFalse(weakHashtable.containsValue(new Long(400)));\n+    }\n+\n+    /** Tests public Enumeration elements() */\n+    public void testElements() throws Exception {\n+        ArrayList elements = new ArrayList();\n+        for (Enumeration e = weakHashtable.elements(); e.hasMoreElements();) {\n+            elements.add(e.nextElement());\n+        }\n+        assertEquals(3, elements.size());\n+        assertTrue(elements.contains(valueOne));\n+        assertTrue(elements.contains(valueTwo));\n+        assertTrue(elements.contains(valueThree));\n+    }\n+\n+    /** Tests public Set entrySet() */\n+    public void testEntrySet() throws Exception {\n+        Set entrySet = weakHashtable.entrySet();\n+        for (Iterator it = entrySet.iterator(); it.hasNext();) {\n+            Map.Entry entry = (Map.Entry) it.next();\n+            Object key = entry.getKey();\n+            if (keyOne.equals(key)) {\n+                assertEquals(valueOne, entry.getValue());\n+            } else if (keyTwo.equals(key)) {\n+                assertEquals(valueTwo, entry.getValue());\n+            } else if (keyThree.equals(key)) {\n+                assertEquals(valueThree, entry.getValue());\n+            } else {\n+                fail(""Unexpected key"");\n+            }\n+        }\n+    }\n+\n+    /** Tests public Object get(Object key) */\n+    public void testGet() throws Exception {\n+        assertEquals(valueOne, weakHashtable.get(keyOne));\n+        assertEquals(valueTwo, weakHashtable.get(keyTwo));\n+        assertEquals(valueThree, weakHashtable.get(keyThree));\n+        assertNull(weakHashtable.get(new Long(50)));\n+    }\n+\n+    /** Tests public Enumeration keys() */\n+    public void testKeys() throws Exception {\n+        ArrayList keys = new ArrayList();\n+        for (Enumeration e = weakHashtable.keys(); e.hasMoreElements();) {\n+            keys.add(e.nextElement());\n+        }\n+        assertEquals(3, keys.size());\n+        assertTrue(keys.contains(keyOne));\n+        assertTrue(keys.contains(keyTwo));\n+        assertTrue(keys.contains(keyThree));\n+    }\n+\n+    /** Tests public Set keySet() */\n+    public void testKeySet() throws Exception {\n+        Set keySet = weakHashtable.keySet();\n+        assertEquals(3, keySet.size());\n+        assertTrue(keySet.contains(keyOne));\n+        assertTrue(keySet.contains(keyTwo));\n+        assertTrue(keySet.contains(keyThree));\n+    }\n+\n+    /** Tests public Object put(Object key, Object value) */\n+    public void testPut() throws Exception {\n+        Long anotherKey = new Long(2004);\n+        weakHashtable.put(anotherKey, new Long(1066));\n+\n+        assertEquals(new Long(1066), weakHashtable.get(anotherKey));\n+\n+        // Test compliance with the hashtable API re nulls\n+        Exception caught = null;\n+        try {\n+            weakHashtable.put(null, new Object());\n+        }\n+        catch (Exception e) {\n+            caught = e;\n+        }\n+        assertNotNull(""did not throw an exception adding a null key"", caught);\n+        caught = null;\n+        try {\n+            weakHashtable.put(new Object(), null);\n+        }\n+        catch (Exception e) {\n+            caught = e;\n+        }\n+        assertNotNull(""did not throw an exception adding a null value"", caught);\n+    }\n+\n+    /** Tests public void putAll(Map t) */\n+    public void testPutAll() throws Exception {\n+        Map newValues = new HashMap();\n+        Long newKey = new Long(1066);\n+        Long newValue = new Long(1415);\n+        newValues.put(newKey, newValue);\n+        Long anotherNewKey = new Long(1645);\n+        Long anotherNewValue = new Long(1815);\n+        newValues.put(anotherNewKey, anotherNewValue);\n+        weakHashtable.putAll(newValues);\n+\n+        assertEquals(5, weakHashtable.size());\n+        assertEquals(newValue, weakHashtable.get(newKey));\n+        assertEquals(anotherNewValue, weakHashtable.get(anotherNewKey));\n+    }\n+\n+    /** Tests public Object remove(Object key) */\n+    public void testRemove() throws Exception {\n+        weakHashtable.remove(keyOne);\n+        assertEquals(2, weakHashtable.size());\n+        assertNull(weakHashtable.get(keyOne));\n+    }\n+\n+    /** Tests public Collection values() */\n+    public void testValues() throws Exception {\n+        Collection values = weakHashtable.values();\n+        assertEquals(3, values.size());\n+        assertTrue(values.contains(valueOne));\n+        assertTrue(values.contains(valueTwo));\n+        assertTrue(values.contains(valueThree));\n+    }\n+\n+    public void testRelease() throws Exception {\n+        assertNotNull(weakHashtable.get(new Long(1)));\n+        ReferenceQueue testQueue = new ReferenceQueue();\n+        WeakReference weakKeyOne = new WeakReference(keyOne, testQueue);\n+\n+        // lose our references\n+        keyOne = null;\n+        keyTwo = null;\n+        keyThree = null;\n+        valueOne = null;\n+        valueTwo = null;\n+        valueThree = null;\n+\n+        int iterations = 0;\n+        int bytz = 2;\n+        while(true) {\n+            System.gc();\n+            if(iterations++ > MAX_GC_ITERATIONS){\n+                fail(""Max iterations reached before resource released."");\n+            }\n+\n+            if(weakHashtable.get(new Long(1)) == null) {\n+                break;\n+\n+            } else {\n+                // create garbage:\n+                byte[] b =  new byte[bytz];\n+                bytz = bytz * 2;\n+            }\n+        }\n+\n+        // some JVMs seem to take a little time to put references on\n+        // the reference queue once the reference has been collected\n+        // need to think about whether this is enough to justify\n+        // stepping through the collection each time...\n+        while(testQueue.poll() == null) {}\n+\n+        // Test that the released objects are not taking space in the table\n+        assertEquals(""underlying table not emptied"", 0, weakHashtable.size());\n+    }\n+\n+    public static class StupidThread extends Thread {\n+\n+        public StupidThread(String name) {\n+            super(name);\n+        }\n+\n+        public void run() {\n+            for (int i = 0; i < RUN_LOOPS; i++) {\n+                hashtable.put(""key"" + "":"" + i%10, Boolean.TRUE);\n+                if(i%50 == 0) {\n+                    yield();\n+                }\n+            }\n+        }\n+    }\n+\n+    public void testLOGGING_119() throws Exception {\n+        Thread [] t = new Thread[THREAD_COUNT];\n+        for (int j=1; j <= OUTER_LOOP; j++) {\n+            hashtable = new WeakHashtable();\n+            for (int i = 0; i < t.length; i++) {\n+                t[i] = new StupidThread(""Thread:"" + i);\n+                t[i].setDaemon(true); // Otherwise we cannot exit\n+                t[i].start();\n+            }\n+            for (int i = 0; i < t.length; i++) {\n+                t[i].join(WAIT_FOR_THREAD_COMPLETION);\n+                if (t[i].isAlive()) {\n+                    break; // at least one thread is stuck\n+                }\n+            }\n+            int active=0;\n+            for (int i = 0; i < t.length; i++) {\n+                if (t[i].isAlive()) {\n+                    active++;\n+                }\n+            }\n+            if (active > 0) {\n+                fail(""Attempt: "" + j + "" Stuck threads: "" + active);\n+            }\n+        }\n+    }\n+}'"
